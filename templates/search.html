{% extends 'base.html' %}

{% block extra_head %}
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/5.4.149/pdf_viewer.min.css">
<script type="module">
    import * as pdfjsLib from 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/5.4.149/pdf.min.mjs';
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/5.4.149/pdf.worker.min.mjs';

    const PDF_DB_NAME = 'codechronicle_pdf_cache';
    const PDF_DB_VERSION = 1;
    const PDF_DB_STORE = 'pdf_mappings';
    const mappingRegistry = new Map();
    const pdfDocumentCache = new Map();
    let dbPromise = null;

    function normalizeFilename(filename) {
        return (filename || '').trim().toLowerCase();
    }

    function expectedKeyFor(filename) {
        return normalizeFilename(filename);
    }

    function humanBytes(value) {
        if (!Number.isFinite(value) || value <= 0) return '0 B';
        const units = ['B', 'KB', 'MB', 'GB'];
        let size = value;
        let unit = 0;
        while (size >= 1024 && unit < units.length - 1) {
            size /= 1024;
            unit += 1;
        }
        const decimals = unit === 0 ? 0 : 1;
        return `${size.toFixed(decimals)} ${units[unit]}`;
    }

    function getPdfDb() {
        if (dbPromise) return dbPromise;
        dbPromise = new Promise((resolve, reject) => {
            const request = indexedDB.open(PDF_DB_NAME, PDF_DB_VERSION);
            request.onupgradeneeded = () => {
                const db = request.result;
                if (!db.objectStoreNames.contains(PDF_DB_STORE)) {
                    db.createObjectStore(PDF_DB_STORE, { keyPath: 'expected_key' });
                }
            };
            request.onsuccess = () => resolve(request.result);
            request.onerror = () => reject(request.error || new Error('Could not open IndexedDB.'));
        });
        return dbPromise;
    }

    async function idbReadAllMappings() {
        const db = await getPdfDb();
        return new Promise((resolve, reject) => {
            const tx = db.transaction(PDF_DB_STORE, 'readonly');
            const store = tx.objectStore(PDF_DB_STORE);
            const request = store.getAll();
            request.onsuccess = () => resolve(request.result || []);
            request.onerror = () => reject(request.error || new Error('Could not read PDF mappings.'));
        });
    }

    async function idbPutMapping(record) {
        const db = await getPdfDb();
        return new Promise((resolve, reject) => {
            const tx = db.transaction(PDF_DB_STORE, 'readwrite');
            tx.oncomplete = () => resolve(undefined);
            tx.onerror = () => reject(tx.error || new Error('Could not store PDF mapping.'));
            tx.objectStore(PDF_DB_STORE).put(record);
        });
    }

    async function idbDeleteMapping(expectedKey) {
        const db = await getPdfDb();
        return new Promise((resolve, reject) => {
            const tx = db.transaction(PDF_DB_STORE, 'readwrite');
            tx.oncomplete = () => resolve(undefined);
            tx.onerror = () => reject(tx.error || new Error('Could not delete PDF mapping.'));
            tx.objectStore(PDF_DB_STORE).delete(expectedKey);
        });
    }

    async function idbClearMappings() {
        const db = await getPdfDb();
        return new Promise((resolve, reject) => {
            const tx = db.transaction(PDF_DB_STORE, 'readwrite');
            tx.oncomplete = () => resolve(undefined);
            tx.onerror = () => reject(tx.error || new Error('Could not clear PDF mappings.'));
            tx.objectStore(PDF_DB_STORE).clear();
        });
    }

    function getMapping(expectedFilename) {
        return mappingRegistry.get(expectedKeyFor(expectedFilename)) || null;
    }

    function clearPdfDocumentCache(expectedKey) {
        for (const key of [...pdfDocumentCache.keys()]) {
            if (key.startsWith(`${expectedKey}:`)) {
                pdfDocumentCache.delete(key);
            }
        }
    }

    async function savePdfMapping(expectedFilename, file) {
        const expected_key = expectedKeyFor(expectedFilename);
        if (!expected_key || !file) return;
        const record = {
            expected_key,
            expected_filename: expectedFilename,
            selected_filename: file.name || expectedFilename,
            blob: file,
            updated_at: Date.now(),
            size: Number(file.size) || 0,
        };
        await idbPutMapping(record);
        mappingRegistry.set(expected_key, record);
        clearPdfDocumentCache(expected_key);
        document.dispatchEvent(new CustomEvent('pdf-mapped', {
            detail: { expectedFilename, expectedKey: expected_key },
        }));
    }

    async function clearPdfMapping(expectedFilename) {
        const expected_key = expectedKeyFor(expectedFilename);
        if (!expected_key) return;
        await idbDeleteMapping(expected_key);
        mappingRegistry.delete(expected_key);
        clearPdfDocumentCache(expected_key);
        document.dispatchEvent(new CustomEvent('pdf-mapped', {
            detail: { expectedFilename, expectedKey: expected_key },
        }));
    }

    async function restorePdfMappings() {
        try {
            const records = await idbReadAllMappings();
            records.forEach(record => {
                if (record && record.expected_key && record.blob instanceof Blob) {
                    mappingRegistry.set(record.expected_key, record);
                }
            });
        } catch (err) {
            console.error('Could not restore local PDF mappings:', err);
        }
    }

    function parseBbox(str) {
        if (!str) return null;
        const parts = str.split(',').map(Number);
        if (parts.length !== 4 || parts.some(isNaN)) return null;
        return { l: parts[0], t: parts[1], r: parts[2], b: parts[3] };
    }

    function parsePdfPage(value) {
        const page = parseInt(value, 10);
        return Number.isFinite(page) && page > 0 ? page : 1;
    }

    function showPdfWarning(container, message) {
        const block = container.closest('[data-pdf-block]');
        if (!block) return;
        const warning = block.querySelector('[data-pdf-warning]');
        if (!warning) return;
        warning.textContent = message || '';
        warning.classList.toggle('hidden', !message);
    }

    function setFallbackVisibility(block, visible) {
        const fallback = block.querySelector('[data-pdf-fallback]');
        if (fallback) {
            fallback.classList.toggle('hidden', !visible);
        }
    }

    function setMappedLabel(block) {
        const container = block.querySelector('[data-pdf-container]');
        const expectedFilename = container?.getAttribute('data-pdf-expected-filename') || '';
        const mapping = getMapping(expectedFilename);
        const label = block.querySelector('[data-pdf-mapped-label]');
        if (label) {
            label.textContent = mapping
                ? `Mapped to: ${mapping.selected_filename}`
                : 'Not mapped yet.';
        }
    }

    function hideMismatchPrompt(block) {
        const mismatch = block.querySelector('[data-pdf-mismatch]');
        if (mismatch) mismatch.classList.add('hidden');
        block._pendingPdfFile = null;
    }

    function showMismatchPrompt(block, expectedFilename, selectedFilename) {
        const mismatch = block.querySelector('[data-pdf-mismatch]');
        if (!mismatch) return;
        const text = mismatch.querySelector('[data-pdf-mismatch-text]');
        if (text) {
            text.textContent = `Selected file "${selectedFilename}" does not match expected "${expectedFilename}".`;
        }
        mismatch.classList.remove('hidden');
    }

    function renderBlockControls(block, state) {
        const mount = block.querySelector('[data-pdf-controls-mount]');
        if (!mount) return;
        const pickerTemplate = block.querySelector('[data-pdf-picker-template]');
        const mappedTemplate = block.querySelector('[data-pdf-mapped-template]');
        const wantsPicker = state === 'picker';
        const source = wantsPicker ? pickerTemplate : mappedTemplate;
        if (!source) return;
        mount.innerHTML = source.innerHTML;
        if (!wantsPicker) {
            hideMismatchPrompt(block);
        }
        setMappedLabel(block);
    }

    function showUnmappedState(container) {
        container.innerHTML = '';
        container.classList.add('hidden');
    }

    async function loadPdfForExpectedFilename(expectedFilename) {
        const mapping = getMapping(expectedFilename);
        if (!mapping || !(mapping.blob instanceof Blob)) return null;
        const cacheKey = `${mapping.expected_key}:${mapping.updated_at}`;
        if (!pdfDocumentCache.has(cacheKey)) {
            const bytes = await mapping.blob.arrayBuffer();
            pdfDocumentCache.set(cacheKey, pdfjsLib.getDocument({ data: bytes }).promise);
        }
        return pdfDocumentCache.get(cacheKey);
    }

    async function renderPdfPage(container, expectedFilename, pageNum, bbox) {
        try {
            const pdf = await loadPdfForExpectedFilename(expectedFilename);
            if (!pdf) {
                showUnmappedState(container);
                const block = container.closest('[data-pdf-block]');
                if (block) {
                    setFallbackVisibility(block, true);
                    showPdfWarning(container, '');
                    renderBlockControls(block, 'picker');
                }
                return false;
            }
            const page = await pdf.getPage(pageNum);

            const containerWidth = container.clientWidth || container.parentElement?.clientWidth || 600;
            const unscaledViewport = page.getViewport({ scale: 1 });
            const pageWidth = unscaledViewport.width;
            const pageHeight = unscaledViewport.height;

            // Detect two-page spread: aspect ratio > 1.4 (landscape)
            const isSpread = pageWidth / pageHeight > 1.4;
            let cropOffsetX = 0;
            let logicalWidth = pageWidth;

            if (isSpread && bbox) {
                const midpoint = pageWidth / 2;
                logicalWidth = pageWidth / 2;
                if (bbox.l >= midpoint) {
                    cropOffsetX = midpoint;
                }
            } else if (isSpread) {
                logicalWidth = pageWidth / 2;
            }

            const scale = containerWidth / logicalWidth;
            const viewport = page.getViewport({ scale });

            // Create wrapper – sized to show only the logical page
            const wrapper = document.createElement('div');
            wrapper.className = 'pdf-page';
            wrapper.style.position = 'relative';
            wrapper.style.width = (logicalWidth * scale) + 'px';
            wrapper.style.height = viewport.height + 'px';
            wrapper.style.overflow = 'hidden';

            // Canvas for rendering – full spread rendered, then shifted
            const canvas = document.createElement('canvas');
            const dpr = window.devicePixelRatio || 1;
            canvas.width = Math.floor(viewport.width * dpr);
            canvas.height = Math.floor(viewport.height * dpr);
            canvas.style.width = viewport.width + 'px';
            canvas.style.height = viewport.height + 'px';
            if (cropOffsetX > 0) {
                canvas.style.marginLeft = -(cropOffsetX * scale) + 'px';
            }
            wrapper.appendChild(canvas);

            const ctx = canvas.getContext('2d');
            ctx.scale(dpr, dpr);
            await page.render({ canvasContext: ctx, viewport }).promise;

            // Highlight bbox region and offset to focus on it
            if (bbox) {
                const x = (bbox.l - cropOffsetX) * scale;
                const y = (pageHeight - bbox.t) * scale;
                const w = (bbox.r - bbox.l) * scale;
                const h = (bbox.t - bbox.b) * scale;

                const highlight = document.createElement('div');
                highlight.className = 'pdf-bbox-highlight';
                highlight.style.cssText = `position:absolute;left:${x}px;top:${y}px;width:${w}px;height:${h}px;`;
                wrapper.appendChild(highlight);

                const offset = Math.max(0, y - 10);
                wrapper.style.marginTop = -offset + 'px';
            }

            // Text layer for selection
            const textContent = await page.getTextContent();
            const textLayerDiv = document.createElement('div');
            textLayerDiv.className = 'textLayer';
            textLayerDiv.style.setProperty('--scale-factor', scale);
            if (cropOffsetX > 0) {
                textLayerDiv.style.left = -(cropOffsetX * scale) + 'px';
            }
            wrapper.appendChild(textLayerDiv);

            const tl = new pdfjsLib.TextLayer({
                textContentSource: textContent,
                container: textLayerDiv,
                viewport: viewport,
            });
            await tl.render();

            container.innerHTML = '';
            container.appendChild(wrapper);
            container.classList.remove('hidden');
            const block = container.closest('[data-pdf-block]');
            if (block) {
                setFallbackVisibility(block, false);
                showPdfWarning(container, '');
                renderBlockControls(block, 'mapped');
            }
            return true;
        } catch (err) {
            const block = container.closest('[data-pdf-block]');
            showUnmappedState(container);
            if (block) {
                setFallbackVisibility(block, true);
                renderBlockControls(block, 'picker');
            }
            const detail = err && err.message ? err.message : 'Unknown PDF loading error.';
            showPdfWarning(container, detail);
            console.error('PDF render error:', err);
            return false;
        }
    }

    function isVisibleElement(element) {
        if (!element) return false;
        const rect = element.getBoundingClientRect();
        return rect.width > 0 && rect.height > 0;
    }

    async function renderContainer(container) {
        if (!container) return;
        const expectedFilename = container.getAttribute('data-pdf-expected-filename') || '';
        const page = parsePdfPage(container.getAttribute('data-pdf-page'));
        const bbox = parseBbox(container.getAttribute('data-pdf-bbox'));
        await renderPdfPage(container, expectedFilename, page, bbox);
    }

    async function handleFileCandidate(block, file, forceOverride = false) {
        if (!block || !file) return;
        const container = block.querySelector('[data-pdf-container]');
        if (!container) return;

        const expectedFilename = container.getAttribute('data-pdf-expected-filename') || '';
        const expectedNormalized = normalizeFilename(expectedFilename);
        const selectedNormalized = normalizeFilename(file.name);
        const isPdfFile = file.type === 'application/pdf' || file.name.toLowerCase().endsWith('.pdf');

        if (!isPdfFile) {
            showPdfWarning(container, 'Selected file is not a PDF.');
            return;
        }

        if (!forceOverride && expectedNormalized && selectedNormalized !== expectedNormalized) {
            block._pendingPdfFile = file;
            showMismatchPrompt(block, expectedFilename, file.name);
            return;
        }

        hideMismatchPrompt(block);
        await savePdfMapping(expectedFilename, file);
    }

    function bindBlockControls(block) {
        if (block.dataset.pdfBound === 'true') return;
        block.dataset.pdfBound = 'true';

        const container = block.querySelector('[data-pdf-container]');
        if (!container) return;
        const expectedFilename = container.getAttribute('data-pdf-expected-filename') || '';

        block.addEventListener('change', async (event) => {
            const source = event.target instanceof Element ? event.target : null;
            if (!source) return;
            const fileInput = source.closest('[data-pdf-file-input]');
            if (!fileInput || !block.contains(fileInput)) return;
            const file = fileInput.files && fileInput.files[0];
            await handleFileCandidate(block, file, false);
            fileInput.value = '';
        });

        block.addEventListener('click', async (event) => {
            const source = event.target instanceof Element ? event.target : null;
            if (!source) return;
            const button = source.closest('button');
            if (!button || !block.contains(button)) return;

            if (button.matches('[data-pdf-clear-mapping]')) {
                await clearPdfMapping(expectedFilename);
                return;
            }
            if (button.matches('[data-pdf-override-mapping]')) {
                if (block._pendingPdfFile) {
                    await handleFileCandidate(block, block._pendingPdfFile, true);
                }
                return;
            }
            if (button.matches('[data-pdf-cancel-mapping]')) {
                hideMismatchPrompt(block);
                return;
            }
            if (button.matches('[data-pdf-show-picker]')) {
                renderBlockControls(block, 'picker');
            }
        });

        block.addEventListener('dragover', (event) => {
            const source = event.target instanceof Element ? event.target : null;
            if (!source) return;
            const dropzone = source.closest('[data-pdf-dropzone]');
            if (!dropzone || !block.contains(dropzone)) return;
            event.preventDefault();
            dropzone.classList.add('pdf-dropzone-active');
        });

        block.addEventListener('dragleave', (event) => {
            const source = event.target instanceof Element ? event.target : null;
            if (!source) return;
            const dropzone = source.closest('[data-pdf-dropzone]');
            if (!dropzone || !block.contains(dropzone)) return;
            dropzone.classList.remove('pdf-dropzone-active');
        });

        block.addEventListener('drop', async (event) => {
            const source = event.target instanceof Element ? event.target : null;
            if (!source) return;
            const dropzone = source.closest('[data-pdf-dropzone]');
            if (!dropzone || !block.contains(dropzone)) return;
            event.preventDefault();
            dropzone.classList.remove('pdf-dropzone-active');
            const file = event.dataTransfer?.files?.[0];
            await handleFileCandidate(block, file, false);
        });

        renderBlockControls(block, getMapping(expectedFilename) ? 'mapped' : 'picker');
    }

    function refreshMappedLabels(expectedKey = null) {
        const blocks = document.querySelectorAll('[data-pdf-block]');
        blocks.forEach(block => {
            const container = block.querySelector('[data-pdf-container]');
            const key = expectedKeyFor(container?.getAttribute('data-pdf-expected-filename'));
            if (!expectedKey || expectedKey === key) {
                setMappedLabel(block);
            }
        });
    }

    async function refreshMatchingVisibleContainers(expectedKey = null) {
        const containers = document.querySelectorAll('[data-pdf-container]');
        for (const container of containers) {
            const key = expectedKeyFor(container.getAttribute('data-pdf-expected-filename'));
            if (expectedKey && key !== expectedKey) continue;
            const block = container.closest('[data-pdf-block]');
            if (!isVisibleElement(block || container)) continue;
            await renderContainer(container);
        }
    }

    async function updateStorageUi() {
        const controls = document.querySelector('[data-pdf-storage-controls]');
        if (!controls) return;
        controls.classList.remove('hidden');

        const entryCount = mappingRegistry.size;
        const usageLabel = controls.querySelector('[data-pdf-storage-usage]');
        const engineLabel = controls.querySelector('[data-pdf-storage-engine]');
        const clearButton = controls.querySelector('[data-pdf-clear-cache]');

        let estimateText = `${entryCount} mapped file${entryCount === 1 ? '' : 's'}`;
        if (navigator.storage?.estimate) {
            try {
                const estimate = await navigator.storage.estimate();
                const used = humanBytes(estimate?.usage || 0);
                const quota = humanBytes(estimate?.quota || 0);
                estimateText += ` | Storage: ${used} / ${quota}`;
            } catch (err) {
                console.error('Storage estimate failed:', err);
            }
        }

        if (usageLabel) usageLabel.textContent = estimateText;
        if (engineLabel) {
            const opfsAvailable = !!(navigator.storage && navigator.storage.getDirectory);
            engineLabel.textContent = opfsAvailable ? 'IndexedDB cache (OPFS available)' : 'IndexedDB cache';
        }
        if (clearButton) clearButton.disabled = entryCount === 0;
    }

    async function initPdfContainers(root) {
        const blocks = (root || document).querySelectorAll('[data-pdf-block]');
        for (const block of blocks) {
            bindBlockControls(block);
        }
        await refreshMatchingVisibleContainers();
        await updateStorageUi();
    }

    async function clearAllPdfMappings() {
        await idbClearMappings();
        mappingRegistry.clear();
        pdfDocumentCache.clear();
        document.dispatchEvent(new CustomEvent('pdf-mapped', {
            detail: { expectedFilename: null, expectedKey: null },
        }));
    }

    document.addEventListener('pdf-mapped', async (event) => {
        const expectedKey = event.detail?.expectedKey || null;
        refreshMappedLabels(expectedKey);
        await refreshMatchingVisibleContainers(expectedKey);
        await updateStorageUi();
    });

    // Init after HTMX injects results
    document.addEventListener('htmx:afterSettle', async (e) => {
        await initPdfContainers(e.detail.elt);
    });

    document.addEventListener('DOMContentLoaded', async () => {
        await restorePdfMappings();
        const clearButton = document.querySelector('[data-pdf-clear-cache]');
        if (clearButton) {
            clearButton.addEventListener('click', async () => {
                await clearAllPdfMappings();
            });
        }
        await initPdfContainers();
    });
</script>
<style>
    .pdf-page {
        position: relative;
    }

    .pdf-page .textLayer {
        position: absolute;
        left: 0;
        top: 0;
        right: 0;
        bottom: 0;
        overflow: hidden;
        opacity: 0.25;
        line-height: 1;
    }

    .pdf-page .textLayer ::selection {
        background: rgba(0, 100, 200, 0.4);
    }

    .pdf-bbox-highlight {
        background: rgba(14, 165, 133, 0.08);
        border: 2px solid rgba(14, 165, 133, 0.4);
        border-radius: 2px;
        pointer-events: none;
    }

    .pdf-collapse-gradient {
        --fade-color: #f1f5f9;
        background: linear-gradient(transparent 60%, var(--fade-color) 100%);
    }

    .dark .pdf-collapse-gradient {
        --fade-color: rgb(38 38 38);
    }

    .pdf-dropzone-active {
        border-color: rgb(14 165 233);
        background: rgba(14, 165, 233, 0.08);
    }
</style>
{% endblock %}

{% block content %}
<div class="max-w-4xl mx-auto px-4 py-8">
    <div class="text-center mb-12">
        <h1 class="text-4xl font-extrabold text-neutral-900 dark:text-white sm:text-5xl">
            Historical Building Code Search
        </h1>
        <p class="mt-4 text-xl text-neutral-500 dark:text-neutral-400">
            Find building code requirements for any construction or renovation date.
        </p>
    </div>

    <!-- Search Form -->
    <div
        class="bg-neutral-100 dark:bg-neutral-800 shadow sm:rounded-lg overflow-hidden border border-neutral-200 dark:border-neutral-700">
        <div class="px-4 py-5 sm:p-6">
            <form hx-post="{% url 'core:search_results' %}" hx-target="#results-area"
                hx-on::before-request="document.getElementById('results-area').innerHTML=document.getElementById('loading-tpl').innerHTML"
                class="space-y-4">
                {% csrf_token %}
                <div class="flex flex-col sm:flex-row gap-4">
                    <div class="flex-grow">
                        <label for="query" class="sr-only">Query</label>
                        <input type="text" name="query" id="query"
                            class="block w-full rounded-md border-neutral-300 dark:border-neutral-600 bg-white dark:bg-neutral-900 shadow-sm focus:border-primary-500 focus:ring-primary-500 sm:text-sm p-3 border dark:text-neutral-100 dark:placeholder-neutral-500"
                            placeholder="e.g. fire safety for house built in 1993 in Ontario"
                            value="{{ initial_query }}" required>
                    </div>
                    <button type="submit"
                        class="inline-flex items-center justify-center px-6 py-3 border border-transparent text-base font-medium rounded-md text-white bg-primary-600 hover:bg-primary-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-primary-500 shadow-sm">
                        Search
                    </button>
                </div>

                <!-- Advanced Options (Alpine.js) -->
                <div x-data="{ open: false }">
                    <button type="button" @click="open = !open"
                        class="text-sm text-primary-600 dark:text-primary-400 hover:text-primary-500 font-medium flex items-center">
                        <span x-text="open ? 'Hide advanced options' : 'Show advanced options'"></span>
                        <svg class="ml-1 h-4 w-4 transform transition-transform" :class="open ? 'rotate-180' : ''"
                            fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" />
                        </svg>
                    </button>

                    <div x-show="open" x-cloak x-transition
                        class="mt-4 p-4 bg-neutral-200 dark:bg-neutral-900/50 rounded-md border border-neutral-100 dark:border-neutral-700/50 grid grid-cols-1 sm:grid-cols-2 gap-4">
                        <div>
                            <label
                                class="block text-xs font-medium text-neutral-500 dark:text-neutral-400 uppercase tracking-wider">Province</label>
                            <select name="province"
                                class="mt-1 block w-full rounded-md border-neutral-300 dark:border-neutral-600 bg-neutral-100 dark:bg-neutral-800 shadow-sm focus:border-primary-500 focus:ring-primary-500 sm:text-sm border p-2 dark:text-neutral-100">
                                <option value="" selected>Auto-detect from query</option>
                                <option value="AB">Alberta</option>
                                <option value="BC">British Columbia</option>
                                <option value="ON">Ontario</option>
                                <option value="QC">Quebec</option>
                            </select>
                            <p class="mt-1 text-xs text-neutral-400 dark:text-neutral-500 italic">Optional: Overrides
                                province in query</p>
                        </div>
                        <div>
                            <label
                                class="block text-xs font-medium text-neutral-500 dark:text-neutral-400 uppercase tracking-wider">Effective
                                Date</label>
                            <input type="date" name="date"
                                class="mt-1 block w-full rounded-md border-neutral-300 dark:border-neutral-600 bg-white dark:bg-neutral-800 shadow-sm focus:border-primary-500 focus:ring-primary-500 sm:text-sm border p-2 dark:text-neutral-100">
                            <p class="mt-1 text-xs text-neutral-400 dark:text-neutral-500 italic">Optional: Overrides
                                date in query</p>
                        </div>
                    </div>
                </div>
            </form>
        </div>
    </div>

    <!-- Loading indicator template (hidden, cloned into results area on submit) -->
    <div id="loading-tpl" class="hidden">
        <div class="text-center py-12">
            <svg class="animate-spin mx-auto h-8 w-8 text-accent-500" xmlns="http://www.w3.org/2000/svg" fill="none"
                viewBox="0 0 24 24">
                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                <path class="opacity-75" fill="currentColor"
                    d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z">
                </path>
            </svg>
            <p class="mt-3 text-sm font-medium text-accent-600 dark:text-accent-400">
                Analyzing query and searching codes...
            </p>
        </div>
    </div>

    <!-- Results Area -->
    <div id="results-area" class="mt-8 space-y-6">
        <!-- Results will be injected here by HTMX -->
        <div class="text-center py-12 opacity-50">
            <svg class="mx-auto h-12 w-12 text-neutral-400 dark:text-neutral-500" fill="none" viewBox="0 0 24 24"
                stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                    d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
            </svg>
            <h3 class="mt-2 text-sm font-medium text-neutral-900 dark:text-neutral-300">No search performed yet</h3>
            <p class="mt-1 text-sm text-neutral-500 dark:text-neutral-400">Ask a question about building codes to get
                started.</p>
        </div>
    </div>

    {% if initial_query %}
    <script>
        document.addEventListener('DOMContentLoaded', function () {
            var form = document.querySelector('[hx-post]');
            if (form) {
                document.getElementById('results-area').innerHTML =
                    document.getElementById('loading-tpl').innerHTML;
                htmx.trigger(form, 'submit');
            }
        });
    </script>
    {% endif %}
</div>
{% endblock %}
